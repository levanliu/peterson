<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>Yanyan&#x27;s Wiki</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" integrity="sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV" crossorigin="anonymous"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.6.0/styles/default.min.css"/><meta name="next-head-count" content="5"/><link rel="preload" href="/_next/static/css/ee15694256147ebe.css" as="style"/><link rel="stylesheet" href="/_next/static/css/ee15694256147ebe.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-f73d82589f972e7d.js" defer=""></script><script src="/_next/static/chunks/framework-66d32731bdd20e83.js" defer=""></script><script src="/_next/static/chunks/main-3929bf55b0f13a18.js" defer=""></script><script src="/_next/static/chunks/pages/_app-d46baf38446a89dd.js" defer=""></script><script src="/_next/static/chunks/pages/%5B%5B...index%5D%5D-28ef7957fcd35a0c.js" defer=""></script><script src="/_next/static/G63gzBpTZjvcKetK-mSAL/_buildManifest.js" defer=""></script><script src="/_next/static/G63gzBpTZjvcKetK-mSAL/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="bg-slate-300/10"><div class="sticky top-0 z-40 w-full backdrop-blur flex-none border-b border-slate-900/10 bg-white/75 supports-backdrop-blur:bg-white/60"><div class="max-w-8xl mx-auto"><div class="py-4 border-b border-slate-900/10 lg:px-8 lg:border-0 dark:border-slate-300/10 mx-4 lg:mx-0"><div class="relative flex items-center"><a href="/">Yanyan&#x27;s wiki</a><div class="relative hidden lg:flex items-center ml-auto"><nav class="text-sm leading-6 font-semibold text-slate-700 dark:text-slate-200"><ul class="flex space-x-8"><li><a class="hover:text-sky-500 dark:hover:text-sky-400" href="/OS/2024/">操作系统 (2024 春)</a></li></ul></nav></div></div></div></div></div><div class="container mx-auto max-w-5xl flex flex-col min-h-screen px-4"><div class="wiki bg-neutral-200/10"><h1>生存指南</h1>
<p><strong>操作系统是一门十分硬核的编程课</strong>，因此如果你还没有完全准备好开始 “编程”、开始面对别人的代码，那可能你需要细心规划一下你的学习路线。当然，也不必焦虑，一来可能 “没学好编程” 不完全是你的责任，二来万事总有开头：</p>
<blockquote>
<p><strong>Don&#x27;t Panic.</strong> ——The Hitchhiker&#x27;s Guide to the Galaxy</p>
</blockquote>
<h2>1. 操作系统为什么难学？</h2>
<p>一直以来，老师们觉得《操作系统》课难教的原因主要是其中的主题既多、涉及的知识又深入，点面无法兼得。举个例子，同学们到目前为止编写的大部分代码都是串行的，就好像是写一个程序模仿 “一个人”，一次执行一步动作。通常《操作系统》课都是第一个引入并发编程的课程 (因为操作系统是最早的并发程序)，也就是你需要协同多个共享内存的 “多个人” 时，会遇到很多你也许意料之外的问题。</p>
<p>很显然，你 “想不清” 这个问题——可以预计，人类已经和并发编程的问题肉搏了几十年，时至今日仍有创新。那么，把这个话题 “讲清楚” 自然是极难的。更糟糕的是，很多课程试图把 “牛逼的现代操作系统” 概念放到课程中 (也许是为了装逼)，但这无异于空中楼阁。《操作系统》课要讲清楚的问题包括：</p>
<ul>
<li>操作系统应该为应用程序提供怎样的 API？</li>
<li>如何用硬件实现多个进程的并发/并行？</li>
<li>如何编写能够工作的并发程序，它不会在压力负载下随时随地崩溃？</li>
<li>如何维持多个隔离的执行流？</li>
<li>如何在磁盘上实现持久的数据结构？</li>
<li>……</li>
</ul>
<p>在解决这些问题上作出突出贡献的人已经得过 n 个图灵奖了——每一个问题都不是吃素的。我们的课程试图把这些问题的来龙去脉、解决方法、代码实现都掌握好，已经相当有挑战性。</p>
<p>操作系统 “难学” 的另一个原因是，想要理解 “操作系统为什么要做成今天这样”，就需要相当的应用编程经验——很多在你有了编程经验后 “理所应当” 的事情，在还不会编程的时候就显得很生硬。某位资深教师曾经问我：“copy-on-write fork 为什么需要引用计数？” 我一时语塞：如果一个共享资源可以自由共享，除了 gc 和引用计数，就没有简单明了的方法去释放它了。这一部分是因为我们的课程设置 “高不成低不就”：</p>
<widget class="quiz-card"><p>❓ <!-- -->第一门编程课的职责是</p><ol><li class="hover:cursor-pointer hover:bg-slate-200">学会用 API 把内心所想用代码表达出来并且爱上编程</li><li class="hover:cursor-pointer hover:bg-slate-200">深入理解一门编程语言的语法和语义，向语言律师迈进一步</li><li class="hover:cursor-pointer hover:bg-slate-200">引导学生取得学分，卷得 GPA</li></ol></widget>
<p>如果你还没有爱上编程，那花一点时间 (包括学习《操作系统》课) 绝对是值得的。现在我们假设大家已经爱上编程，讨论操作系统该怎么学。</p>
<h2>2. 操作系统该怎么学？</h2>
<blockquote>
<p><strong>Don&#x27;t Panic. Everything is a state machine.</strong> ——The Hitchhiker&#x27;s Guide to Operating Systems</p>
</blockquote>
<p>幸运的是，我们在多年的经验里找到了理解操作系统的三把 “钥匙” (尤其是很特别的第三把钥匙)，从三个视角里，“从外向里” 一点一点深入地观测操作系统，直到形成对操作系统完整、一致的理解。</p>
<h3>🔑-1 <strong>在程序眼中，操作系统 = 对象 + API</strong></h3>
<widget><p>操作系统为应用程序提供了执行的基础环境、一系列操作系统对象和操作它们的 API——至少对于今天的操作系统来说，这些东西都是精确定义、触手可及的。我们可以在课堂上通过代码片段、调试工具、日志、trace 等等实在地触摸到操作系统为应用程序提供的一切。这就帮助我们理解现代操作系统<red>设计</red>背后的思路。</p></widget>
<p>我们会学习真实操作系统中的程序是什么，以及如何借助操作系统提供的 API 为操作系统编程。具体来说，我们的选择是 Linux (准确来说是 POSIX) 作为课程教学的平台，因为它既免费也自由 (能知道它内部的实现)，而且互联网上有丰富的 (英文) 文档。它的设计继承自 “Keep it simple, stupid” 的 UNIX，这个经典的设计背后的动机反而更容易为第一次接触操作系统的初学者所理解，也会贯穿整个课程。</p>
<p>选择 Linux 的另一个原因是它的开源基础——你能找到 Linux 世界中几乎任何程序的源代码！例如，你是否好奇 “文本编辑器” 是怎样实现的？命令行中的 Vim 看起来很酷，但你可能没有学过实现它所必须的编程知识。一方面，你可以求助 AI，另一方面，你也可以直接找一个 “简化版” 的实现，例如早期 busybox 的 <a href="https://git.busybox.net/busybox/tree/editors/vi.c?h=1_00_stable">vi.c</a>。扫一眼代码，你甚至会发现下面的注释：</p>
<pre><code class="hljs language-c"><span class="hljs-comment">/* To compile for standalone use:
 *	gcc -Wall -Os -s -DSTANDALONE -o vi vi.c ... */</span>
</code></pre>
<p>看不懂也没关系，我们有人工智能。AI 给了相当好的答案：</p>
<blockquote>
<p>GPT-4-turbo: 这个命令是在使用 GCC (GNU Compiler Collection) 编译器编译一个名为 <code>vi.c</code> 的C语言源文件，并生成一个名为 <code>vi</code> 的可执行文件。命令中的各个选项含义如下：<code>-Wall</code>: 开启所有的警告信息，帮助开发者发现代码中可能的问题。<code>-Os</code>: 优化编译后的代码，使其在大小上进行优化，即尽可能减小生成的可执行文件的大小。<code>-s</code>: 去除符号表和调试信息，这也有助于减小最终可执行文件的大小。<code>-DSTANDALONE</code>: 定义一个宏 <code>STANDALONE</code>，这通常用于条件编译。在源代码中，可以使用 <code>#ifdef STANDALONE</code> 来检查这个宏是否被定义，从而决定是否编译某些特定的代码块。<code>-o vi</code>: 指定输出的可执行文件名为 <code>vi</code>。综上所述，这个命令的目的是编译 <code>vi.c</code> 文件，并生成一个优化过的、体积较小的、没有调试信息的 <code>vi</code> 可执行文件。</p>
</blockquote>
<p>这个文件也许比你写过的任何项目都大 (4000 行)，但你如果使用正确的工具把函数代码折叠起来，你会发现这简单，你也写得出，而且它包含了实现 “命令行图形界面” 的必要代码，例如如何移动光标、如何清除屏幕等，你依葫芦画瓢也能写出来！Standalone 编译可能会遇到一些小麻烦 (但如果你有好的编程基础，不用怕，你可以解决这些小问题)，一旦解决了一些未定义的函数问题，你就真的得到了一个可以编译运行的文本编辑器：</p>
<p><img src="img/vi.c.png" alt=""/></p>
<p>没错。我们就是通过编写各种有趣的实际程序理解操作系统为应用程序提供的对象和 API——在这些对象和 API 上构建了我们肉眼可见的一切：浏览器、编辑器、游戏、游戏外挂、虚拟机……包括为了帮助大家更好地理解操作系统的 API，我们还设置了若干 Linux 系统上的 Mini Programming Labs，每个 200 行左右的代码，实际调用 Linux 操作系统 API 完成一些仅使用 C 标准库难以办到的任务。</p>
<h3>🔑-2 <strong>在硬件眼中，操作系统 = C 程序</strong></h3>
<widget><p>如果你完全理解了操作系统中有什么对象、如何操纵它们，就只剩一个问题：你能用计算机硬件提供的机制把这些对象和 API 实现出来吗？实际上，运算和访存指令、I/O、中断/异常和虚存就是我们实现操作系统所需的全部。<red>实现</red>操作系统就是硬件和体系结构知识基础上的普通 “编程活”。</p></widget>
<p>从我们初学编程开始就知道，我们的代码从 main 函数开始执行，下面的程序能打印出 Hello World:</p>
<pre><code class="hljs language-c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> {
  <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-type">char</span> *p = <span class="hljs-string">&quot;Hello World\n&quot;</span>; *p; p++) {
   <span class="hljs-built_in">putchar</span>(*p);
  }
}
</code></pre>
<p>一模一样的代码，能直接在没有操作系统的硬件上运行，并且打印出 Hello World 吗？答案是肯定的——前提是我们需要做好一系列的准备：AI 也给出了 “需要做什么” 的正确答案：</p>
<ol>
<li><strong>启动代码 (Bootloader)</strong>：在没有操作系统的硬件上，你需要一个启动加载程序 (bootloader) 来初始化硬件并加载你的程序到内存中。</li>
<li><strong>硬件初始化</strong>：你的程序需要包含初始化硬件的代码，比如设置堆栈、初始化中断向量表、配置时钟、设置内存管理单元等。</li>
<li><strong>直接硬件访问</strong>：你需要编写代码直接与硬件通信，比如通过内存映射的I/O或特殊的硬件寄存器来发送字符到串行端口、LCD显示屏或其他输出设备。</li>
<li><strong>自定义输出函数</strong>：由于标准库函数如 <code>putchar</code> 不可用，你需要编写自己的输出函数来替代它，这个函数将直接与你选择的输出硬件接口交互。</li>
</ol>
<p>没错！我们的确需要编写一些 “底层代码”，一旦编写完成 (也不用害怕，我们会为同学们提供友好的代码框架)，我们的 “操作系统” 就完全可以用 C 语言编写了。事实上，UNIX 自诞生以来，就不断有人在实现新的操作系统——一个成功的例子就是 Linux，在它之上还有或许更为成功的 Android。UNIX 也有更多 “迷你版” 的替代实现，能容易地帮助大家理解代码背后的原理。我们在课堂上选用 <a href="http://pdos.csail.mit.edu/6.S081/xv6">xv6-riscv</a> 作为讲解操作系统的例子。同时，大家也需要在 Operating System Labs 中，从 “裸机” (bare-metal) 编程开始，自底向上实现一个支持多处理器、文件系统、虚拟存储的迷你操作系统内核。</p>
<h3>🔑-3 <strong>在上帝眼中，操作系统 = 一个数学对象</strong></h3>
<widget><p>这也是我们多年以来找到最有趣的视角：我们可以把计算机系统 (电路) 建模成有限状态机模型，当然也可以把运行在硬件上的任何软件 (包括操作系统) 建模成状态机。这个视角不仅可以给我们带来许多有趣的思想实验，也指导我们真正把 “数学对象” 实现出来，并用代码自动分析和<red>理解</red>它们。</p></widget>
<p>我们从小到大学过很多数学，我们习惯于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo><mi>sin</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">y = \sin(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em"></span><span class="mord mathnormal" style="margin-right:0.03588em">y</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mop">sin</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span> 这样的 “函数”。但 “函数” 的定义发生了微妙的变化：我们可以在 <code>main</code> “函数” 里调用 <code>printf()</code> 打印，因此计算机世界中的函数，和数学世界中的函数就很难被联系起来了。</p>
<p>从另一个角度，数学的视角又总是伴随着我们的计算机程序。例如，我们可以把编译器想象成一个，它接受一个程序 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal" style="margin-right:0.13889em">P</span></span></span></span> 作为输入，而 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>P</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">C = f(P)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal" style="margin-right:0.07153em">C</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.10764em">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em">P</span><span class="mclose">)</span></span></span></span> 得到编译后的二进制代码。同样，我们也可以把计算机想象成一个数学函数，如果把所有内存、寄存器的数值想象成一个巨大的数字 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal">x</span></span></span></span>，计算机每执行一条指令，就会得到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>x</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">x&#x27; = f(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7519em"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.10764em">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>，即 “执行指令之后的计算机状态”。</p>
<p>如果我们的计算机系统和程序都是数学对象，我们能不能像研究数学对象一样 (例如，证明 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mi>x</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">f(x) = x^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.10764em">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.8141em"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span> 相对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em"></span><span class="mord mathnormal" style="margin-right:0.03588em">y</span></span></span></span> 轴对称)，证明关于计算机程序和系统的数学性质？答案是肯定的。我们将在这门课中用通俗的方式引入 “形式化方法”，而这个视角最终将帮助我们更严格地理解计算机系统地方方面面。</p>
<h3>迈出第一步</h3>
<p>如果你还没有入门，仍然感到恐惧，请记住：坚持住，进入未知领域，<red><strong>从简单的、能理解的东西试起，投入时间，就有收获</strong></red>。<a href="References.md">参考资料</a>中有一些非常棒的入门材料，例如 “Harley Hahn&#x27;s Guide to Unix and Linux”，引人入胜 (这本书不是写给计算机专业人士的，所以它异常好读且有中文版)。从这里开始，你就能慢慢克服恐惧了。</p>
<p>同样，你可能会对一小段程序 (例如课堂上的示例代码) 感到难以理解。程序难读是很正常的——但程序的运行时状态是好理解的。无非就是数字和指针嘛。请你勇敢地打开你的调试器，设置一个断点，单步执行你的程序。不知道怎么调试？调试的时候没有代码？做好阅读互联网资料的准备，也准备好你身边的 AI 助手，然后现在就开始吧！</p>
<div class="hidden"><h3>3.2 自测：C 语言编程</h3><p>直到今天这门课依然使用 C 语言。在阐述操作系统原理方面，它更简单、包袱更少，也没有很庞大的工具链。虽然说这相当于 “把你的手脚捆起来编程”，但我们通常不需要很复杂的数据结构和代码逻辑，因此现代语言特性的好处在大部分时候并不显著。而且用 C 语言还有一些额外的好处：</p><ul>
<li>和其他编程语言相比，C 语言特性更容易真正掌握和深入理解。如果你没有学好，用几周的时间补上应该也没问题</li>
<li>C 是一种 “高级的汇编语言”，你不难在大脑里把 C 出代码翻译成指令序列；但对于现代语言来说，这要困难得多</li>
<li>透过对 C 语言的深入理解，可以更好地理解现代编程语言的设计动机和实现方法</li>
</ul><p>一个例子是 “面向对象”，我们在 C 里也可以实现</p><pre><code class="hljs language-c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">foo</span> {</span>
  <span class="hljs-type">int</span> (*bar)(<span class="hljs-keyword">struct</span> foo *this, <span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b); <span class="hljs-comment">// 函数指针</span>
};

<span class="hljs-type">void</span> <span class="hljs-title function_">baz</span><span class="hljs-params">()</span> {
  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">foo</span> *<span class="hljs-title">ptr</span> =</span> get_object();
  ptr-&gt;bar(ptr, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>);
  <span class="hljs-comment">// 等效于C++: ptr-&gt;bar(3, 4)</span>
}
</code></pre><p>而 C++ 里的对象，的确也是这样 (类似) 实现的。如果要实现动态绑定 (用父类的指针调用子类的方法)，我们只需把虚函数的入口放到一张表中，通过查表得到函数实际的入口地址：</p><pre><code class="hljs language-c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">object_header</span> {</span>
  <span class="hljs-type">void</span> **vptr;
};

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">foo</span> {</span>
  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">object_header</span> <span class="hljs-title">header</span>;</span>
  ...
};

<span class="hljs-type">void</span> baz {
  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">foo</span> *<span class="hljs-title">ptr</span> =</span> get_object();
  <span class="hljs-comment">// ptr-&gt;bar(3, 4), dynamic binding</span>
  <span class="hljs-comment">// INDEX_OF_BAR在编译时由编译器确定</span>
  (<span class="hljs-type">int</span> (*)(<span class="hljs-type">void</span> *, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>)) (ptr-&gt;header.vptr[INDEX_OF_BAR]) (ptr, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>);
}
</code></pre><p>能理解上述的例子，说明你已经有相当扎实的 C 语言基础了。如果不能，建议大家阅读参考书中推荐的 “The C programming language”。</p><blockquote>
<h4>思考题：多重继承</h4>
<p>C++ 支持多重继承，即一个类可以拥有两个父类。你想到多重继承的实现方法了吗？多重继承的实现是把多个父类同时嵌入进来 (会拥有两个 <code>header</code>)。编译器会处理好调用、动态绑定等问题。</p>
<p>从写 C 程序的角度 (操作系统也就是个运行在计算机硬件上的 C 程序)，所谓 “编程” 不过是用那些编程语言提供的机制，把内存里的数据取出来，算一算，再放回去。There is <em>no</em> magic in computer systems.</p>
</blockquote><p>只有在泥潭里摸爬滚打很多年，死了一次又一次，才能体会 C++11/14/17/20+, Rust, Go 等现代程序设计语言的良苦用心。</p><h3>3.3 自测：编程技巧</h3><p>选修过《计算机系统基础》，或是任何开发过相当规模项目的的同学一定已经经历过调试 bug 的噩梦。无数次你打算放弃 (或者实际放弃)，或选择不要某个 labs/PA 的成绩，或选择抱大腿同学的实现……你们做出的妥协都可以理解，但在这个过程中忽略的调试经验，只会让你们在调试越来越大系统的时候越来越吃力。</p><p>我们的自测问题是：如果你一个很大的项目发现了 bug (假设你可以稳定地重现它)，你应该如何找到出问题的地方所在？</p><ul>
<li><code>printf</code> 是个很不错的方法；但你遇到过花费很长时间也没有找到 bug 的情况么？</li>
<li>如果 <code>printf</code> 帮助你找到了一些线索，如何进一步快速确定问题的 root cause？</li>
<li>如果项目很大，使用调试器单步就有些太繁琐了。你有什么技巧？(例如 watch point)</li>
</ul><p>如果你对这些问题心里都有一些答案，那祝贺你！如果你一直在使用 “蛮力” 调试，的确有可能过去的代码你还能处理，但对于规模不断增长的代码，这就有些行不通了。</p><blockquote>
<h4>思考题：怎样尽可能编出<strong>正确</strong>的代码？</h4>
<p>在 “面向 OJ 编程” 成为习惯以后，编程不过 “是测试 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em"></span><span class="mrel">→</span></span></span></span> 不通过 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em"></span><span class="mrel">→</span></span></span></span> 修改” 的循环。但如果你希望<strong>说服别人你的代码真的是对的</strong>，你有什么办法吗？</p>
<p>试着提前想一想这个问题。这个学期里，大家会面对多线程并发的编程，这时候程序的正确性就尤为重要，只靠 “盲试” 就有些不够了。</p>
</blockquote><h2>4. 其他常见问题</h2><p>Q: <strong>说好的操作系统呢？为什么没有图形界面？？？我是不是学了假的操作系统？？？？</strong></p><p>A: 你如果把终端的每一个字符看成是像素点，那终端也勉强算是个 “图形” 界面了。</p><p>实际上，操作系统也是这么管理图形界面的——由一个程序 (可能运行在 GPU 上) 算出每个像素点该显示什么颜色，就像 vi 在终端上显示字符、导航栏一样。当像素点足够小的时候，你就有图形的感觉了：</p><p>(<a href="http://ascii-patrol.com/">ASCII Patrol</a>：上面的 “图形” 真的都是 ASCII 字符组成的！)</p><p>当然，图形绘制涉及到的知识太多，课程上就不多啰嗦了，假装能完成这个类比，无法假装的同学可以选修著名的 <a href="https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html">Games 101</a>。</p><p>Q: <strong>为什么不是C++/Go/Rust/...?</strong></p><p>A: <strong>我们并不需要 “更高级” 的语言，依然可以编写优雅、深刻的代码，这对初学者来说尤为重要，不会 “顾此失彼”</strong>。</p><p>好的语言特性使程序变得优雅——但对于初学者，这些特性背后的东西 (例如 C++ RTTI) 可能给你带来未知的麻烦。而在这门课上，退一步并没有什么损失：我们不需要实现什么高级数据结构；用 C 语言也能写出优雅的代码，就像 xv6 那样。还有两点额外好处：</p><ul>
<li>C 语言代码始终有非常直白的汇编语言一致性。</li>
<li>通过在 C 语言编程时体会缺失的部分，能更好地理解现代编程语言中的机制。如果你熟悉现代 C++/Rust，你就会对对象的 ownership 非常敏感。即便你在写 C，这种好的思维习惯依然会时刻保护你。如果你想得更远一些，你依然可以在 C 中通过 assertions 近似地表达出 <a href="https://prl.ccs.neu.edu/blog/static/refinement_types_lecture.pdf">Refinement Types</a>。</li>
</ul><p>Golang/Rust/C++ 都可以用来实现操作系统，不过似乎现在对大家来说负担稍稍有些重。</p><p>Q: <strong>我想退课/蹭课？</strong></p><p>A: 上课可以督促你写好代码。而<strong>不写代码这门课就白上了</strong>；理解这一点，欢迎蹭课。如果觉得基础没有打好，就先努力学好 C 语言。这门课的唯一要求就是<strong>会使用 C 语言编程</strong>，还有<strong>能读懂手册</strong>。</p><p>Q: <strong>我想做纯理论。代码什么的关我️✖️事？</strong></p><p>A: 有那个智力和坚持，写点 C 代码真是太简单了。花一点时间去理解写代码的关键，顺利完成课程不是问题；计算机系统/编程语言领域也有许多和理论交叉的课题。</p><p>Q: <strong>我还是好怕。</strong>
A: Don&#x27;t Panic。不要慌，在 Office Hours 的时候来聊一聊。</p></div></div></div><div class="bg-neutral-100 text-center text-neutral-600 dark:bg-neutral-600 dark:text-neutral-200 lg:text-left"><div class="bg-neutral-200 p-6 text-center dark:bg-neutral-700"><a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">Creative Commons License: BY-NC 4.0</a><br/><a href="https://beian.miit.gov.cn/">苏 ICP 备 2020049101 号</a></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"source":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h1: \"h1\",\n    p: \"p\",\n    strong: \"strong\",\n    blockquote: \"blockquote\",\n    h2: \"h2\",\n    ul: \"ul\",\n    li: \"li\",\n    h3: \"h3\",\n    a: \"a\",\n    pre: \"pre\",\n    code: \"code\",\n    span: \"span\",\n    img: \"img\",\n    ol: \"ol\",\n    math: \"math\",\n    semantics: \"semantics\",\n    mrow: \"mrow\",\n    mi: \"mi\",\n    mo: \"mo\",\n    annotation: \"annotation\",\n    msup: \"msup\",\n    mn: \"mn\",\n    h4: \"h4\",\n    em: \"em\"\n  }, _provideComponents(), props.components), {Quiz} = _components;\n  if (!Quiz) _missingMdxReference(\"Quiz\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.h1, {\n      children: \"生存指南\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"操作系统是一门十分硬核的编程课\"\n      }), \"，因此如果你还没有完全准备好开始 “编程”、开始面对别人的代码，那可能你需要细心规划一下你的学习路线。当然，也不必焦虑，一来可能 “没学好编程” 不完全是你的责任，二来万事总有开头：\"]\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsxs(_components.p, {\n        children: [_jsx(_components.strong, {\n          children: \"Don't Panic.\"\n        }), \" ——The Hitchhiker's Guide to the Galaxy\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"1. 操作系统为什么难学？\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"一直以来，老师们觉得《操作系统》课难教的原因主要是其中的主题既多、涉及的知识又深入，点面无法兼得。举个例子，同学们到目前为止编写的大部分代码都是串行的，就好像是写一个程序模仿 “一个人”，一次执行一步动作。通常《操作系统》课都是第一个引入并发编程的课程 (因为操作系统是最早的并发程序)，也就是你需要协同多个共享内存的 “多个人” 时，会遇到很多你也许意料之外的问题。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"很显然，你 “想不清” 这个问题——可以预计，人类已经和并发编程的问题肉搏了几十年，时至今日仍有创新。那么，把这个话题 “讲清楚” 自然是极难的。更糟糕的是，很多课程试图把 “牛逼的现代操作系统” 概念放到课程中 (也许是为了装逼)，但这无异于空中楼阁。《操作系统》课要讲清楚的问题包括：\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"操作系统应该为应用程序提供怎样的 API？\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"如何用硬件实现多个进程的并发/并行？\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"如何编写能够工作的并发程序，它不会在压力负载下随时随地崩溃？\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"如何维持多个隔离的执行流？\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"如何在磁盘上实现持久的数据结构？\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"……\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"在解决这些问题上作出突出贡献的人已经得过 n 个图灵奖了——每一个问题都不是吃素的。我们的课程试图把这些问题的来龙去脉、解决方法、代码实现都掌握好，已经相当有挑战性。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"操作系统 “难学” 的另一个原因是，想要理解 “操作系统为什么要做成今天这样”，就需要相当的应用编程经验——很多在你有了编程经验后 “理所应当” 的事情，在还不会编程的时候就显得很生硬。某位资深教师曾经问我：“copy-on-write fork 为什么需要引用计数？” 我一时语塞：如果一个共享资源可以自由共享，除了 gc 和引用计数，就没有简单明了的方法去释放它了。这一部分是因为我们的课程设置 “高不成低不就”：\"\n    }), \"\\n\", _jsx(Quiz, {\n      question: {\n        question: '第一门编程课的职责是',\n        options: ['学会用 API 把内心所想用代码表达出来并且爱上编程', '深入理解一门编程语言的语法和语义，向语言律师迈进一步', '引导学生取得学分，卷得 GPA'],\n        answer: 0,\n        comment: '从游戏、数值计算、符号求解到深度学习，“编程” 是改变世界的力量。'\n      }\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"如果你还没有爱上编程，那花一点时间 (包括学习《操作系统》课) 绝对是值得的。现在我们假设大家已经爱上编程，讨论操作系统该怎么学。\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"2. 操作系统该怎么学？\"\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsxs(_components.p, {\n        children: [_jsx(_components.strong, {\n          children: \"Don't Panic. Everything is a state machine.\"\n        }), \" ——The Hitchhiker's Guide to Operating Systems\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"幸运的是，我们在多年的经验里找到了理解操作系统的三把 “钥匙” (尤其是很特别的第三把钥匙)，从三个视角里，“从外向里” 一点一点深入地观测操作系统，直到形成对操作系统完整、一致的理解。\"\n    }), \"\\n\", _jsxs(_components.h3, {\n      children: [\"🔑-1 \", _jsx(_components.strong, {\n        children: \"在程序眼中，操作系统 = 对象 + API\"\n      })]\n    }), \"\\n\", _jsx(\"widget\", {\n      children: _jsxs(_components.p, {\n        children: [\"操作系统为应用程序提供了执行的基础环境、一系列操作系统对象和操作它们的 API——至少对于今天的操作系统来说，这些东西都是精确定义、触手可及的。我们可以在课堂上通过代码片段、调试工具、日志、trace 等等实在地触摸到操作系统为应用程序提供的一切。这就帮助我们理解现代操作系统\", _jsx(\"red\", {\n          children: \"设计\"\n        }), \"背后的思路。\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"我们会学习真实操作系统中的程序是什么，以及如何借助操作系统提供的 API 为操作系统编程。具体来说，我们的选择是 Linux (准确来说是 POSIX) 作为课程教学的平台，因为它既免费也自由 (能知道它内部的实现)，而且互联网上有丰富的 (英文) 文档。它的设计继承自 “Keep it simple, stupid” 的 UNIX，这个经典的设计背后的动机反而更容易为第一次接触操作系统的初学者所理解，也会贯穿整个课程。\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"选择 Linux 的另一个原因是它的开源基础——你能找到 Linux 世界中几乎任何程序的源代码！例如，你是否好奇 “文本编辑器” 是怎样实现的？命令行中的 Vim 看起来很酷，但你可能没有学过实现它所必须的编程知识。一方面，你可以求助 AI，另一方面，你也可以直接找一个 “简化版” 的实现，例如早期 busybox 的 \", _jsx(_components.a, {\n        href: \"https://git.busybox.net/busybox/tree/editors/vi.c?h=1_00_stable\",\n        children: \"vi.c\"\n      }), \"。扫一眼代码，你甚至会发现下面的注释：\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-c\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"/* To compile for standalone use:\\n *\\tgcc -Wall -Os -s -DSTANDALONE -o vi vi.c ... */\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"看不懂也没关系，我们有人工智能。AI 给了相当好的答案：\"\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsxs(_components.p, {\n        children: [\"GPT-4-turbo: 这个命令是在使用 GCC (GNU Compiler Collection) 编译器编译一个名为 \", _jsx(_components.code, {\n          children: \"vi.c\"\n        }), \" 的C语言源文件，并生成一个名为 \", _jsx(_components.code, {\n          children: \"vi\"\n        }), \" 的可执行文件。命令中的各个选项含义如下：\", _jsx(_components.code, {\n          children: \"-Wall\"\n        }), \": 开启所有的警告信息，帮助开发者发现代码中可能的问题。\", _jsx(_components.code, {\n          children: \"-Os\"\n        }), \": 优化编译后的代码，使其在大小上进行优化，即尽可能减小生成的可执行文件的大小。\", _jsx(_components.code, {\n          children: \"-s\"\n        }), \": 去除符号表和调试信息，这也有助于减小最终可执行文件的大小。\", _jsx(_components.code, {\n          children: \"-DSTANDALONE\"\n        }), \": 定义一个宏 \", _jsx(_components.code, {\n          children: \"STANDALONE\"\n        }), \"，这通常用于条件编译。在源代码中，可以使用 \", _jsx(_components.code, {\n          children: \"#ifdef STANDALONE\"\n        }), \" 来检查这个宏是否被定义，从而决定是否编译某些特定的代码块。\", _jsx(_components.code, {\n          children: \"-o vi\"\n        }), \": 指定输出的可执行文件名为 \", _jsx(_components.code, {\n          children: \"vi\"\n        }), \"。综上所述，这个命令的目的是编译 \", _jsx(_components.code, {\n          children: \"vi.c\"\n        }), \" 文件，并生成一个优化过的、体积较小的、没有调试信息的 \", _jsx(_components.code, {\n          children: \"vi\"\n        }), \" 可执行文件。\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"这个文件也许比你写过的任何项目都大 (4000 行)，但你如果使用正确的工具把函数代码折叠起来，你会发现这简单，你也写得出，而且它包含了实现 “命令行图形界面” 的必要代码，例如如何移动光标、如何清除屏幕等，你依葫芦画瓢也能写出来！Standalone 编译可能会遇到一些小麻烦 (但如果你有好的编程基础，不用怕，你可以解决这些小问题)，一旦解决了一些未定义的函数问题，你就真的得到了一个可以编译运行的文本编辑器：\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"img/vi.c.png\",\n        alt: \"\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"没错。我们就是通过编写各种有趣的实际程序理解操作系统为应用程序提供的对象和 API——在这些对象和 API 上构建了我们肉眼可见的一切：浏览器、编辑器、游戏、游戏外挂、虚拟机……包括为了帮助大家更好地理解操作系统的 API，我们还设置了若干 Linux 系统上的 Mini Programming Labs，每个 200 行左右的代码，实际调用 Linux 操作系统 API 完成一些仅使用 C 标准库难以办到的任务。\"\n    }), \"\\n\", _jsxs(_components.h3, {\n      children: [\"🔑-2 \", _jsx(_components.strong, {\n        children: \"在硬件眼中，操作系统 = C 程序\"\n      })]\n    }), \"\\n\", _jsx(\"widget\", {\n      children: _jsxs(_components.p, {\n        children: [\"如果你完全理解了操作系统中有什么对象、如何操纵它们，就只剩一个问题：你能用计算机硬件提供的机制把这些对象和 API 实现出来吗？实际上，运算和访存指令、I/O、中断/异常和虚存就是我们实现操作系统所需的全部。\", _jsx(\"red\", {\n          children: \"实现\"\n        }), \"操作系统就是硬件和体系结构知识基础上的普通 “编程活”。\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"从我们初学编程开始就知道，我们的代码从 main 函数开始执行，下面的程序能打印出 Hello World:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-c\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"int\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"main\"\n        }), _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"()\"\n        }), \" {\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"for\"\n        }), \" (\", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"const\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"char\"\n        }), \" *p = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Hello World\\\\n\\\"\"\n        }), \"; *p; p++) {\\n   \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"putchar\"\n        }), \"(*p);\\n  }\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"一模一样的代码，能直接在没有操作系统的硬件上运行，并且打印出 Hello World 吗？答案是肯定的——前提是我们需要做好一系列的准备：AI 也给出了 “需要做什么” 的正确答案：\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"启动代码 (Bootloader)\"\n        }), \"：在没有操作系统的硬件上，你需要一个启动加载程序 (bootloader) 来初始化硬件并加载你的程序到内存中。\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"硬件初始化\"\n        }), \"：你的程序需要包含初始化硬件的代码，比如设置堆栈、初始化中断向量表、配置时钟、设置内存管理单元等。\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"直接硬件访问\"\n        }), \"：你需要编写代码直接与硬件通信，比如通过内存映射的I/O或特殊的硬件寄存器来发送字符到串行端口、LCD显示屏或其他输出设备。\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"自定义输出函数\"\n        }), \"：由于标准库函数如 \", _jsx(_components.code, {\n          children: \"putchar\"\n        }), \" 不可用，你需要编写自己的输出函数来替代它，这个函数将直接与你选择的输出硬件接口交互。\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"没错！我们的确需要编写一些 “底层代码”，一旦编写完成 (也不用害怕，我们会为同学们提供友好的代码框架)，我们的 “操作系统” 就完全可以用 C 语言编写了。事实上，UNIX 自诞生以来，就不断有人在实现新的操作系统——一个成功的例子就是 Linux，在它之上还有或许更为成功的 Android。UNIX 也有更多 “迷你版” 的替代实现，能容易地帮助大家理解代码背后的原理。我们在课堂上选用 \", _jsx(_components.a, {\n        href: \"http://pdos.csail.mit.edu/6.S081/xv6\",\n        children: \"xv6-riscv\"\n      }), \" 作为讲解操作系统的例子。同时，大家也需要在 Operating System Labs 中，从 “裸机” (bare-metal) 编程开始，自底向上实现一个支持多处理器、文件系统、虚拟存储的迷你操作系统内核。\"]\n    }), \"\\n\", _jsxs(_components.h3, {\n      children: [\"🔑-3 \", _jsx(_components.strong, {\n        children: \"在上帝眼中，操作系统 = 一个数学对象\"\n      })]\n    }), \"\\n\", _jsx(\"widget\", {\n      children: _jsxs(_components.p, {\n        children: [\"这也是我们多年以来找到最有趣的视角：我们可以把计算机系统 (电路) 建模成有限状态机模型，当然也可以把运行在硬件上的任何软件 (包括操作系统) 建模成状态机。这个视角不仅可以给我们带来许多有趣的思想实验，也指导我们真正把 “数学对象” 实现出来，并用代码自动分析和\", _jsx(\"red\", {\n          children: \"理解\"\n        }), \"它们。\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"我们从小到大学过很多数学，我们习惯于 \", _jsxs(_components.span, {\n        className: \"katex\",\n        children: [_jsx(_components.span, {\n          className: \"katex-mathml\",\n          children: _jsx(_components.math, {\n            xmlns: \"http://www.w3.org/1998/Math/MathML\",\n            children: _jsxs(_components.semantics, {\n              children: [_jsxs(_components.mrow, {\n                children: [_jsx(_components.mi, {\n                  children: \"y\"\n                }), _jsx(_components.mo, {\n                  children: \"=\"\n                }), _jsx(_components.mi, {\n                  children: \"sin\"\n                }), _jsx(_components.mo, {\n                  children: \"⁡\"\n                }), _jsx(_components.mo, {\n                  stretchy: \"false\",\n                  children: \"(\"\n                }), _jsx(_components.mi, {\n                  children: \"x\"\n                }), _jsx(_components.mo, {\n                  stretchy: \"false\",\n                  children: \")\"\n                })]\n              }), _jsx(_components.annotation, {\n                encoding: \"application/x-tex\",\n                children: \"y = \\\\sin(x)\"\n              })]\n            })\n          })\n        }), _jsxs(_components.span, {\n          className: \"katex-html\",\n          \"aria-hidden\": \"true\",\n          children: [_jsxs(_components.span, {\n            className: \"base\",\n            children: [_jsx(_components.span, {\n              className: \"strut\",\n              style: {\n                height: \"0.625em\",\n                verticalAlign: \"-0.1944em\"\n              }\n            }), _jsx(_components.span, {\n              className: \"mord mathnormal\",\n              style: {\n                marginRight: \"0.03588em\"\n              },\n              children: \"y\"\n            }), _jsx(_components.span, {\n              className: \"mspace\",\n              style: {\n                marginRight: \"0.2778em\"\n              }\n            }), _jsx(_components.span, {\n              className: \"mrel\",\n              children: \"=\"\n            }), _jsx(_components.span, {\n              className: \"mspace\",\n              style: {\n                marginRight: \"0.2778em\"\n              }\n            })]\n          }), _jsxs(_components.span, {\n            className: \"base\",\n            children: [_jsx(_components.span, {\n              className: \"strut\",\n              style: {\n                height: \"1em\",\n                verticalAlign: \"-0.25em\"\n              }\n            }), _jsx(_components.span, {\n              className: \"mop\",\n              children: \"sin\"\n            }), _jsx(_components.span, {\n              className: \"mopen\",\n              children: \"(\"\n            }), _jsx(_components.span, {\n              className: \"mord mathnormal\",\n              children: \"x\"\n            }), _jsx(_components.span, {\n              className: \"mclose\",\n              children: \")\"\n            })]\n          })]\n        })]\n      }), \" 这样的 “函数”。但 “函数” 的定义发生了微妙的变化：我们可以在 \", _jsx(_components.code, {\n        children: \"main\"\n      }), \" “函数” 里调用 \", _jsx(_components.code, {\n        children: \"printf()\"\n      }), \" 打印，因此计算机世界中的函数，和数学世界中的函数就很难被联系起来了。\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"从另一个角度，数学的视角又总是伴随着我们的计算机程序。例如，我们可以把编译器想象成一个，它接受一个程序 \", _jsxs(_components.span, {\n        className: \"katex\",\n        children: [_jsx(_components.span, {\n          className: \"katex-mathml\",\n          children: _jsx(_components.math, {\n            xmlns: \"http://www.w3.org/1998/Math/MathML\",\n            children: _jsxs(_components.semantics, {\n              children: [_jsx(_components.mrow, {\n                children: _jsx(_components.mi, {\n                  children: \"P\"\n                })\n              }), _jsx(_components.annotation, {\n                encoding: \"application/x-tex\",\n                children: \"P\"\n              })]\n            })\n          })\n        }), _jsx(_components.span, {\n          className: \"katex-html\",\n          \"aria-hidden\": \"true\",\n          children: _jsxs(_components.span, {\n            className: \"base\",\n            children: [_jsx(_components.span, {\n              className: \"strut\",\n              style: {\n                height: \"0.6833em\"\n              }\n            }), _jsx(_components.span, {\n              className: \"mord mathnormal\",\n              style: {\n                marginRight: \"0.13889em\"\n              },\n              children: \"P\"\n            })]\n          })\n        })]\n      }), \" 作为输入，而 \", _jsxs(_components.span, {\n        className: \"katex\",\n        children: [_jsx(_components.span, {\n          className: \"katex-mathml\",\n          children: _jsx(_components.math, {\n            xmlns: \"http://www.w3.org/1998/Math/MathML\",\n            children: _jsxs(_components.semantics, {\n              children: [_jsxs(_components.mrow, {\n                children: [_jsx(_components.mi, {\n                  children: \"C\"\n                }), _jsx(_components.mo, {\n                  children: \"=\"\n                }), _jsx(_components.mi, {\n                  children: \"f\"\n                }), _jsx(_components.mo, {\n                  stretchy: \"false\",\n                  children: \"(\"\n                }), _jsx(_components.mi, {\n                  children: \"P\"\n                }), _jsx(_components.mo, {\n                  stretchy: \"false\",\n                  children: \")\"\n                })]\n              }), _jsx(_components.annotation, {\n                encoding: \"application/x-tex\",\n                children: \"C = f(P)\"\n              })]\n            })\n          })\n        }), _jsxs(_components.span, {\n          className: \"katex-html\",\n          \"aria-hidden\": \"true\",\n          children: [_jsxs(_components.span, {\n            className: \"base\",\n            children: [_jsx(_components.span, {\n              className: \"strut\",\n              style: {\n                height: \"0.6833em\"\n              }\n            }), _jsx(_components.span, {\n              className: \"mord mathnormal\",\n              style: {\n                marginRight: \"0.07153em\"\n              },\n              children: \"C\"\n            }), _jsx(_components.span, {\n              className: \"mspace\",\n              style: {\n                marginRight: \"0.2778em\"\n              }\n            }), _jsx(_components.span, {\n              className: \"mrel\",\n              children: \"=\"\n            }), _jsx(_components.span, {\n              className: \"mspace\",\n              style: {\n                marginRight: \"0.2778em\"\n              }\n            })]\n          }), _jsxs(_components.span, {\n            className: \"base\",\n            children: [_jsx(_components.span, {\n              className: \"strut\",\n              style: {\n                height: \"1em\",\n                verticalAlign: \"-0.25em\"\n              }\n            }), _jsx(_components.span, {\n              className: \"mord mathnormal\",\n              style: {\n                marginRight: \"0.10764em\"\n              },\n              children: \"f\"\n            }), _jsx(_components.span, {\n              className: \"mopen\",\n              children: \"(\"\n            }), _jsx(_components.span, {\n              className: \"mord mathnormal\",\n              style: {\n                marginRight: \"0.13889em\"\n              },\n              children: \"P\"\n            }), _jsx(_components.span, {\n              className: \"mclose\",\n              children: \")\"\n            })]\n          })]\n        })]\n      }), \" 得到编译后的二进制代码。同样，我们也可以把计算机想象成一个数学函数，如果把所有内存、寄存器的数值想象成一个巨大的数字 \", _jsxs(_components.span, {\n        className: \"katex\",\n        children: [_jsx(_components.span, {\n          className: \"katex-mathml\",\n          children: _jsx(_components.math, {\n            xmlns: \"http://www.w3.org/1998/Math/MathML\",\n            children: _jsxs(_components.semantics, {\n              children: [_jsx(_components.mrow, {\n                children: _jsx(_components.mi, {\n                  children: \"x\"\n                })\n              }), _jsx(_components.annotation, {\n                encoding: \"application/x-tex\",\n                children: \"x\"\n              })]\n            })\n          })\n        }), _jsx(_components.span, {\n          className: \"katex-html\",\n          \"aria-hidden\": \"true\",\n          children: _jsxs(_components.span, {\n            className: \"base\",\n            children: [_jsx(_components.span, {\n              className: \"strut\",\n              style: {\n                height: \"0.4306em\"\n              }\n            }), _jsx(_components.span, {\n              className: \"mord mathnormal\",\n              children: \"x\"\n            })]\n          })\n        })]\n      }), \"，计算机每执行一条指令，就会得到 \", _jsxs(_components.span, {\n        className: \"katex\",\n        children: [_jsx(_components.span, {\n          className: \"katex-mathml\",\n          children: _jsx(_components.math, {\n            xmlns: \"http://www.w3.org/1998/Math/MathML\",\n            children: _jsxs(_components.semantics, {\n              children: [_jsxs(_components.mrow, {\n                children: [_jsxs(_components.msup, {\n                  children: [_jsx(_components.mi, {\n                    children: \"x\"\n                  }), _jsx(_components.mo, {\n                    mathvariant: \"normal\",\n                    lspace: \"0em\",\n                    rspace: \"0em\",\n                    children: \"′\"\n                  })]\n                }), _jsx(_components.mo, {\n                  children: \"=\"\n                }), _jsx(_components.mi, {\n                  children: \"f\"\n                }), _jsx(_components.mo, {\n                  stretchy: \"false\",\n                  children: \"(\"\n                }), _jsx(_components.mi, {\n                  children: \"x\"\n                }), _jsx(_components.mo, {\n                  stretchy: \"false\",\n                  children: \")\"\n                })]\n              }), _jsx(_components.annotation, {\n                encoding: \"application/x-tex\",\n                children: \"x' = f(x)\"\n              })]\n            })\n          })\n        }), _jsxs(_components.span, {\n          className: \"katex-html\",\n          \"aria-hidden\": \"true\",\n          children: [_jsxs(_components.span, {\n            className: \"base\",\n            children: [_jsx(_components.span, {\n              className: \"strut\",\n              style: {\n                height: \"0.7519em\"\n              }\n            }), _jsxs(_components.span, {\n              className: \"mord\",\n              children: [_jsx(_components.span, {\n                className: \"mord mathnormal\",\n                children: \"x\"\n              }), _jsx(_components.span, {\n                className: \"msupsub\",\n                children: _jsx(_components.span, {\n                  className: \"vlist-t\",\n                  children: _jsx(_components.span, {\n                    className: \"vlist-r\",\n                    children: _jsx(_components.span, {\n                      className: \"vlist\",\n                      style: {\n                        height: \"0.7519em\"\n                      },\n                      children: _jsxs(_components.span, {\n                        style: {\n                          top: \"-3.063em\",\n                          marginRight: \"0.05em\"\n                        },\n                        children: [_jsx(_components.span, {\n                          className: \"pstrut\",\n                          style: {\n                            height: \"2.7em\"\n                          }\n                        }), _jsx(_components.span, {\n                          className: \"sizing reset-size6 size3 mtight\",\n                          children: _jsx(_components.span, {\n                            className: \"mord mtight\",\n                            children: _jsx(_components.span, {\n                              className: \"mord mtight\",\n                              children: \"′\"\n                            })\n                          })\n                        })]\n                      })\n                    })\n                  })\n                })\n              })]\n            }), _jsx(_components.span, {\n              className: \"mspace\",\n              style: {\n                marginRight: \"0.2778em\"\n              }\n            }), _jsx(_components.span, {\n              className: \"mrel\",\n              children: \"=\"\n            }), _jsx(_components.span, {\n              className: \"mspace\",\n              style: {\n                marginRight: \"0.2778em\"\n              }\n            })]\n          }), _jsxs(_components.span, {\n            className: \"base\",\n            children: [_jsx(_components.span, {\n              className: \"strut\",\n              style: {\n                height: \"1em\",\n                verticalAlign: \"-0.25em\"\n              }\n            }), _jsx(_components.span, {\n              className: \"mord mathnormal\",\n              style: {\n                marginRight: \"0.10764em\"\n              },\n              children: \"f\"\n            }), _jsx(_components.span, {\n              className: \"mopen\",\n              children: \"(\"\n            }), _jsx(_components.span, {\n              className: \"mord mathnormal\",\n              children: \"x\"\n            }), _jsx(_components.span, {\n              className: \"mclose\",\n              children: \")\"\n            })]\n          })]\n        })]\n      }), \"，即 “执行指令之后的计算机状态”。\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"如果我们的计算机系统和程序都是数学对象，我们能不能像研究数学对象一样 (例如，证明 \", _jsxs(_components.span, {\n        className: \"katex\",\n        children: [_jsx(_components.span, {\n          className: \"katex-mathml\",\n          children: _jsx(_components.math, {\n            xmlns: \"http://www.w3.org/1998/Math/MathML\",\n            children: _jsxs(_components.semantics, {\n              children: [_jsxs(_components.mrow, {\n                children: [_jsx(_components.mi, {\n                  children: \"f\"\n                }), _jsx(_components.mo, {\n                  stretchy: \"false\",\n                  children: \"(\"\n                }), _jsx(_components.mi, {\n                  children: \"x\"\n                }), _jsx(_components.mo, {\n                  stretchy: \"false\",\n                  children: \")\"\n                }), _jsx(_components.mo, {\n                  children: \"=\"\n                }), _jsxs(_components.msup, {\n                  children: [_jsx(_components.mi, {\n                    children: \"x\"\n                  }), _jsx(_components.mn, {\n                    children: \"2\"\n                  })]\n                })]\n              }), _jsx(_components.annotation, {\n                encoding: \"application/x-tex\",\n                children: \"f(x) = x^2\"\n              })]\n            })\n          })\n        }), _jsxs(_components.span, {\n          className: \"katex-html\",\n          \"aria-hidden\": \"true\",\n          children: [_jsxs(_components.span, {\n            className: \"base\",\n            children: [_jsx(_components.span, {\n              className: \"strut\",\n              style: {\n                height: \"1em\",\n                verticalAlign: \"-0.25em\"\n              }\n            }), _jsx(_components.span, {\n              className: \"mord mathnormal\",\n              style: {\n                marginRight: \"0.10764em\"\n              },\n              children: \"f\"\n            }), _jsx(_components.span, {\n              className: \"mopen\",\n              children: \"(\"\n            }), _jsx(_components.span, {\n              className: \"mord mathnormal\",\n              children: \"x\"\n            }), _jsx(_components.span, {\n              className: \"mclose\",\n              children: \")\"\n            }), _jsx(_components.span, {\n              className: \"mspace\",\n              style: {\n                marginRight: \"0.2778em\"\n              }\n            }), _jsx(_components.span, {\n              className: \"mrel\",\n              children: \"=\"\n            }), _jsx(_components.span, {\n              className: \"mspace\",\n              style: {\n                marginRight: \"0.2778em\"\n              }\n            })]\n          }), _jsxs(_components.span, {\n            className: \"base\",\n            children: [_jsx(_components.span, {\n              className: \"strut\",\n              style: {\n                height: \"0.8141em\"\n              }\n            }), _jsxs(_components.span, {\n              className: \"mord\",\n              children: [_jsx(_components.span, {\n                className: \"mord mathnormal\",\n                children: \"x\"\n              }), _jsx(_components.span, {\n                className: \"msupsub\",\n                children: _jsx(_components.span, {\n                  className: \"vlist-t\",\n                  children: _jsx(_components.span, {\n                    className: \"vlist-r\",\n                    children: _jsx(_components.span, {\n                      className: \"vlist\",\n                      style: {\n                        height: \"0.8141em\"\n                      },\n                      children: _jsxs(_components.span, {\n                        style: {\n                          top: \"-3.063em\",\n                          marginRight: \"0.05em\"\n                        },\n                        children: [_jsx(_components.span, {\n                          className: \"pstrut\",\n                          style: {\n                            height: \"2.7em\"\n                          }\n                        }), _jsx(_components.span, {\n                          className: \"sizing reset-size6 size3 mtight\",\n                          children: _jsx(_components.span, {\n                            className: \"mord mtight\",\n                            children: \"2\"\n                          })\n                        })]\n                      })\n                    })\n                  })\n                })\n              })]\n            })]\n          })]\n        })]\n      }), \" 相对于 \", _jsxs(_components.span, {\n        className: \"katex\",\n        children: [_jsx(_components.span, {\n          className: \"katex-mathml\",\n          children: _jsx(_components.math, {\n            xmlns: \"http://www.w3.org/1998/Math/MathML\",\n            children: _jsxs(_components.semantics, {\n              children: [_jsx(_components.mrow, {\n                children: _jsx(_components.mi, {\n                  children: \"y\"\n                })\n              }), _jsx(_components.annotation, {\n                encoding: \"application/x-tex\",\n                children: \"y\"\n              })]\n            })\n          })\n        }), _jsx(_components.span, {\n          className: \"katex-html\",\n          \"aria-hidden\": \"true\",\n          children: _jsxs(_components.span, {\n            className: \"base\",\n            children: [_jsx(_components.span, {\n              className: \"strut\",\n              style: {\n                height: \"0.625em\",\n                verticalAlign: \"-0.1944em\"\n              }\n            }), _jsx(_components.span, {\n              className: \"mord mathnormal\",\n              style: {\n                marginRight: \"0.03588em\"\n              },\n              children: \"y\"\n            })]\n          })\n        })]\n      }), \" 轴对称)，证明关于计算机程序和系统的数学性质？答案是肯定的。我们将在这门课中用通俗的方式引入 “形式化方法”，而这个视角最终将帮助我们更严格地理解计算机系统地方方面面。\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"迈出第一步\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"如果你还没有入门，仍然感到恐惧，请记住：坚持住，进入未知领域，\", _jsx(\"red\", {\n        children: _jsx(_components.strong, {\n          children: \"从简单的、能理解的东西试起，投入时间，就有收获\"\n        })\n      }), \"。\", _jsx(_components.a, {\n        href: \"References.md\",\n        children: \"参考资料\"\n      }), \"中有一些非常棒的入门材料，例如 “Harley Hahn's Guide to Unix and Linux”，引人入胜 (这本书不是写给计算机专业人士的，所以它异常好读且有中文版)。从这里开始，你就能慢慢克服恐惧了。\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"同样，你可能会对一小段程序 (例如课堂上的示例代码) 感到难以理解。程序难读是很正常的——但程序的运行时状态是好理解的。无非就是数字和指针嘛。请你勇敢地打开你的调试器，设置一个断点，单步执行你的程序。不知道怎么调试？调试的时候没有代码？做好阅读互联网资料的准备，也准备好你身边的 AI 助手，然后现在就开始吧！\"\n    }), \"\\n\", _jsxs(\"div\", {\n      className: \"hidden\",\n      children: [_jsx(_components.h3, {\n        children: \"3.2 自测：C 语言编程\"\n      }), _jsx(_components.p, {\n        children: \"直到今天这门课依然使用 C 语言。在阐述操作系统原理方面，它更简单、包袱更少，也没有很庞大的工具链。虽然说这相当于 “把你的手脚捆起来编程”，但我们通常不需要很复杂的数据结构和代码逻辑，因此现代语言特性的好处在大部分时候并不显著。而且用 C 语言还有一些额外的好处：\"\n      }), _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"和其他编程语言相比，C 语言特性更容易真正掌握和深入理解。如果你没有学好，用几周的时间补上应该也没问题\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"C 是一种 “高级的汇编语言”，你不难在大脑里把 C 出代码翻译成指令序列；但对于现代语言来说，这要困难得多\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"透过对 C 语言的深入理解，可以更好地理解现代编程语言的设计动机和实现方法\"\n        }), \"\\n\"]\n      }), _jsx(_components.p, {\n        children: \"一个例子是 “面向对象”，我们在 C 里也可以实现\"\n      }), _jsx(_components.pre, {\n        children: _jsxs(_components.code, {\n          className: \"hljs language-c\",\n          children: [_jsxs(_components.span, {\n            className: \"hljs-class\",\n            children: [_jsx(_components.span, {\n              className: \"hljs-keyword\",\n              children: \"struct\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-title\",\n              children: \"foo\"\n            }), \" {\"]\n          }), \"\\n  \", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"int\"\n          }), \" (*bar)(\", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"struct\"\n          }), \" foo *this, \", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"int\"\n          }), \" a, \", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"int\"\n          }), \" b); \", _jsx(_components.span, {\n            className: \"hljs-comment\",\n            children: \"// 函数指针\"\n          }), \"\\n};\\n\\n\", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"void\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title function_\",\n            children: \"baz\"\n          }), _jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"()\"\n          }), \" {\\n  \", _jsxs(_components.span, {\n            className: \"hljs-class\",\n            children: [_jsx(_components.span, {\n              className: \"hljs-keyword\",\n              children: \"struct\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-title\",\n              children: \"foo\"\n            }), \" *\", _jsx(_components.span, {\n              className: \"hljs-title\",\n              children: \"ptr\"\n            }), \" =\"]\n          }), \" get_object();\\n  ptr-\u003ebar(ptr, \", _jsx(_components.span, {\n            className: \"hljs-number\",\n            children: \"3\"\n          }), \", \", _jsx(_components.span, {\n            className: \"hljs-number\",\n            children: \"4\"\n          }), \");\\n  \", _jsx(_components.span, {\n            className: \"hljs-comment\",\n            children: \"// 等效于C++: ptr-\u003ebar(3, 4)\"\n          }), \"\\n}\\n\"]\n        })\n      }), _jsx(_components.p, {\n        children: \"而 C++ 里的对象，的确也是这样 (类似) 实现的。如果要实现动态绑定 (用父类的指针调用子类的方法)，我们只需把虚函数的入口放到一张表中，通过查表得到函数实际的入口地址：\"\n      }), _jsx(_components.pre, {\n        children: _jsxs(_components.code, {\n          className: \"hljs language-c\",\n          children: [_jsxs(_components.span, {\n            className: \"hljs-class\",\n            children: [_jsx(_components.span, {\n              className: \"hljs-keyword\",\n              children: \"struct\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-title\",\n              children: \"object_header\"\n            }), \" {\"]\n          }), \"\\n  \", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"void\"\n          }), \" **vptr;\\n};\\n\\n\", _jsxs(_components.span, {\n            className: \"hljs-class\",\n            children: [_jsx(_components.span, {\n              className: \"hljs-keyword\",\n              children: \"struct\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-title\",\n              children: \"foo\"\n            }), \" {\"]\n          }), \"\\n  \", _jsxs(_components.span, {\n            className: \"hljs-class\",\n            children: [_jsx(_components.span, {\n              className: \"hljs-keyword\",\n              children: \"struct\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-title\",\n              children: \"object_header\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-title\",\n              children: \"header\"\n            }), \";\"]\n          }), \"\\n  ...\\n};\\n\\n\", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"void\"\n          }), \" baz {\\n  \", _jsxs(_components.span, {\n            className: \"hljs-class\",\n            children: [_jsx(_components.span, {\n              className: \"hljs-keyword\",\n              children: \"struct\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-title\",\n              children: \"foo\"\n            }), \" *\", _jsx(_components.span, {\n              className: \"hljs-title\",\n              children: \"ptr\"\n            }), \" =\"]\n          }), \" get_object();\\n  \", _jsx(_components.span, {\n            className: \"hljs-comment\",\n            children: \"// ptr-\u003ebar(3, 4), dynamic binding\"\n          }), \"\\n  \", _jsx(_components.span, {\n            className: \"hljs-comment\",\n            children: \"// INDEX_OF_BAR在编译时由编译器确定\"\n          }), \"\\n  (\", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"int\"\n          }), \" (*)(\", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"void\"\n          }), \" *, \", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"int\"\n          }), \", \", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"int\"\n          }), \")) (ptr-\u003eheader.vptr[INDEX_OF_BAR]) (ptr, \", _jsx(_components.span, {\n            className: \"hljs-number\",\n            children: \"3\"\n          }), \", \", _jsx(_components.span, {\n            className: \"hljs-number\",\n            children: \"4\"\n          }), \");\\n}\\n\"]\n        })\n      }), _jsx(_components.p, {\n        children: \"能理解上述的例子，说明你已经有相当扎实的 C 语言基础了。如果不能，建议大家阅读参考书中推荐的 “The C programming language”。\"\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.h4, {\n          children: \"思考题：多重继承\"\n        }), \"\\n\", _jsxs(_components.p, {\n          children: [\"C++ 支持多重继承，即一个类可以拥有两个父类。你想到多重继承的实现方法了吗？多重继承的实现是把多个父类同时嵌入进来 (会拥有两个 \", _jsx(_components.code, {\n            children: \"header\"\n          }), \")。编译器会处理好调用、动态绑定等问题。\"]\n        }), \"\\n\", _jsxs(_components.p, {\n          children: [\"从写 C 程序的角度 (操作系统也就是个运行在计算机硬件上的 C 程序)，所谓 “编程” 不过是用那些编程语言提供的机制，把内存里的数据取出来，算一算，再放回去。There is \", _jsx(_components.em, {\n            children: \"no\"\n          }), \" magic in computer systems.\"]\n        }), \"\\n\"]\n      }), _jsx(_components.p, {\n        children: \"只有在泥潭里摸爬滚打很多年，死了一次又一次，才能体会 C++11/14/17/20+, Rust, Go 等现代程序设计语言的良苦用心。\"\n      }), _jsx(_components.h3, {\n        children: \"3.3 自测：编程技巧\"\n      }), _jsx(_components.p, {\n        children: \"选修过《计算机系统基础》，或是任何开发过相当规模项目的的同学一定已经经历过调试 bug 的噩梦。无数次你打算放弃 (或者实际放弃)，或选择不要某个 labs/PA 的成绩，或选择抱大腿同学的实现……你们做出的妥协都可以理解，但在这个过程中忽略的调试经验，只会让你们在调试越来越大系统的时候越来越吃力。\"\n      }), _jsx(_components.p, {\n        children: \"我们的自测问题是：如果你一个很大的项目发现了 bug (假设你可以稳定地重现它)，你应该如何找到出问题的地方所在？\"\n      }), _jsxs(_components.ul, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.code, {\n            children: \"printf\"\n          }), \" 是个很不错的方法；但你遇到过花费很长时间也没有找到 bug 的情况么？\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"如果 \", _jsx(_components.code, {\n            children: \"printf\"\n          }), \" 帮助你找到了一些线索，如何进一步快速确定问题的 root cause？\"]\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"如果项目很大，使用调试器单步就有些太繁琐了。你有什么技巧？(例如 watch point)\"\n        }), \"\\n\"]\n      }), _jsx(_components.p, {\n        children: \"如果你对这些问题心里都有一些答案，那祝贺你！如果你一直在使用 “蛮力” 调试，的确有可能过去的代码你还能处理，但对于规模不断增长的代码，这就有些行不通了。\"\n      }), _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsxs(_components.h4, {\n          children: [\"思考题：怎样尽可能编出\", _jsx(_components.strong, {\n            children: \"正确\"\n          }), \"的代码？\"]\n        }), \"\\n\", _jsxs(_components.p, {\n          children: [\"在 “面向 OJ 编程” 成为习惯以后，编程不过 “是测试 \", _jsxs(_components.span, {\n            className: \"katex\",\n            children: [_jsx(_components.span, {\n              className: \"katex-mathml\",\n              children: _jsx(_components.math, {\n                xmlns: \"http://www.w3.org/1998/Math/MathML\",\n                children: _jsxs(_components.semantics, {\n                  children: [_jsx(_components.mrow, {\n                    children: _jsx(_components.mo, {\n                      children: \"→\"\n                    })\n                  }), _jsx(_components.annotation, {\n                    encoding: \"application/x-tex\",\n                    children: \"\\\\to\"\n                  })]\n                })\n              })\n            }), _jsx(_components.span, {\n              className: \"katex-html\",\n              \"aria-hidden\": \"true\",\n              children: _jsxs(_components.span, {\n                className: \"base\",\n                children: [_jsx(_components.span, {\n                  className: \"strut\",\n                  style: {\n                    height: \"0.3669em\"\n                  }\n                }), _jsx(_components.span, {\n                  className: \"mrel\",\n                  children: \"→\"\n                })]\n              })\n            })]\n          }), \" 不通过 \", _jsxs(_components.span, {\n            className: \"katex\",\n            children: [_jsx(_components.span, {\n              className: \"katex-mathml\",\n              children: _jsx(_components.math, {\n                xmlns: \"http://www.w3.org/1998/Math/MathML\",\n                children: _jsxs(_components.semantics, {\n                  children: [_jsx(_components.mrow, {\n                    children: _jsx(_components.mo, {\n                      children: \"→\"\n                    })\n                  }), _jsx(_components.annotation, {\n                    encoding: \"application/x-tex\",\n                    children: \"\\\\to\"\n                  })]\n                })\n              })\n            }), _jsx(_components.span, {\n              className: \"katex-html\",\n              \"aria-hidden\": \"true\",\n              children: _jsxs(_components.span, {\n                className: \"base\",\n                children: [_jsx(_components.span, {\n                  className: \"strut\",\n                  style: {\n                    height: \"0.3669em\"\n                  }\n                }), _jsx(_components.span, {\n                  className: \"mrel\",\n                  children: \"→\"\n                })]\n              })\n            })]\n          }), \" 修改” 的循环。但如果你希望\", _jsx(_components.strong, {\n            children: \"说服别人你的代码真的是对的\"\n          }), \"，你有什么办法吗？\"]\n        }), \"\\n\", _jsx(_components.p, {\n          children: \"试着提前想一想这个问题。这个学期里，大家会面对多线程并发的编程，这时候程序的正确性就尤为重要，只靠 “盲试” 就有些不够了。\"\n        }), \"\\n\"]\n      }), _jsx(_components.h2, {\n        children: \"4. 其他常见问题\"\n      }), _jsxs(_components.p, {\n        children: [\"Q: \", _jsx(_components.strong, {\n          children: \"说好的操作系统呢？为什么没有图形界面？？？我是不是学了假的操作系统？？？？\"\n        })]\n      }), _jsx(_components.p, {\n        children: \"A: 你如果把终端的每一个字符看成是像素点，那终端也勉强算是个 “图形” 界面了。\"\n      }), _jsx(_components.p, {\n        children: \"实际上，操作系统也是这么管理图形界面的——由一个程序 (可能运行在 GPU 上) 算出每个像素点该显示什么颜色，就像 vi 在终端上显示字符、导航栏一样。当像素点足够小的时候，你就有图形的感觉了：\"\n      }), _jsxs(_components.p, {\n        children: [\"(\", _jsx(_components.a, {\n          href: \"http://ascii-patrol.com/\",\n          children: \"ASCII Patrol\"\n        }), \"：上面的 “图形” 真的都是 ASCII 字符组成的！)\"]\n      }), _jsxs(_components.p, {\n        children: [\"当然，图形绘制涉及到的知识太多，课程上就不多啰嗦了，假装能完成这个类比，无法假装的同学可以选修著名的 \", _jsx(_components.a, {\n          href: \"https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html\",\n          children: \"Games 101\"\n        }), \"。\"]\n      }), _jsxs(_components.p, {\n        children: [\"Q: \", _jsx(_components.strong, {\n          children: \"为什么不是C++/Go/Rust/...?\"\n        })]\n      }), _jsxs(_components.p, {\n        children: [\"A: \", _jsx(_components.strong, {\n          children: \"我们并不需要 “更高级” 的语言，依然可以编写优雅、深刻的代码，这对初学者来说尤为重要，不会 “顾此失彼”\"\n        }), \"。\"]\n      }), _jsx(_components.p, {\n        children: \"好的语言特性使程序变得优雅——但对于初学者，这些特性背后的东西 (例如 C++ RTTI) 可能给你带来未知的麻烦。而在这门课上，退一步并没有什么损失：我们不需要实现什么高级数据结构；用 C 语言也能写出优雅的代码，就像 xv6 那样。还有两点额外好处：\"\n      }), _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"C 语言代码始终有非常直白的汇编语言一致性。\"\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"通过在 C 语言编程时体会缺失的部分，能更好地理解现代编程语言中的机制。如果你熟悉现代 C++/Rust，你就会对对象的 ownership 非常敏感。即便你在写 C，这种好的思维习惯依然会时刻保护你。如果你想得更远一些，你依然可以在 C 中通过 assertions 近似地表达出 \", _jsx(_components.a, {\n            href: \"https://prl.ccs.neu.edu/blog/static/refinement_types_lecture.pdf\",\n            children: \"Refinement Types\"\n          }), \"。\"]\n        }), \"\\n\"]\n      }), _jsx(_components.p, {\n        children: \"Golang/Rust/C++ 都可以用来实现操作系统，不过似乎现在对大家来说负担稍稍有些重。\"\n      }), _jsxs(_components.p, {\n        children: [\"Q: \", _jsx(_components.strong, {\n          children: \"我想退课/蹭课？\"\n        })]\n      }), _jsxs(_components.p, {\n        children: [\"A: 上课可以督促你写好代码。而\", _jsx(_components.strong, {\n          children: \"不写代码这门课就白上了\"\n        }), \"；理解这一点，欢迎蹭课。如果觉得基础没有打好，就先努力学好 C 语言。这门课的唯一要求就是\", _jsx(_components.strong, {\n          children: \"会使用 C 语言编程\"\n        }), \"，还有\", _jsx(_components.strong, {\n          children: \"能读懂手册\"\n        }), \"。\"]\n      }), _jsxs(_components.p, {\n        children: [\"Q: \", _jsx(_components.strong, {\n          children: \"我想做纯理论。代码什么的关我️✖️事？\"\n        })]\n      }), _jsx(_components.p, {\n        children: \"A: 有那个智力和坚持，写点 C 代码真是太简单了。花一点时间去理解写代码的关键，顺利完成课程不是问题；计算机系统/编程语言领域也有许多和理论交叉的课题。\"\n      }), _jsxs(_components.p, {\n        children: [\"Q: \", _jsx(_components.strong, {\n          children: \"我还是好怕。\"\n        }), \"\\nA: Don't Panic。不要慌，在 Office Hours 的时候来聊一聊。\"]\n      })]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","frontmatter":{},"scope":{}},"frontmatter":{}},"__N_SSG":true},"page":"/[[...index]]","query":{"index":["OS","Guide.md"]},"buildId":"G63gzBpTZjvcKetK-mSAL","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>